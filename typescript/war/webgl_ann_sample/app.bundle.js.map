{
  "version": 3,
  "sources": ["../../src/Network.ts", "../../src/Layer.ts", "../../src/Link.ts", "../../src/Neuron.ts", "../../src/Pattern.ts", "../../src/ModelFactory.ts", "../../src/index.ts"],
  "sourcesContent": ["import {Layer} from './Layer';\nimport {Pattern} from './Pattern';\n\nexport class Network {\n    private static readonly GAMMA = 2.0;\n    private static readonly ALPHA = 0.1;\n    private static readonly WEIGHT_DECAY = 4.0;\n    private static readonly FLAT_SPOT = 0.001;\n\n    private layers: Layer[] = [];\n\n    addLayer(layer: Layer) {\n        this.layers.push(layer);\n    }\n\n    getLayers() {\n        return this.layers;\n    }\n\n    recallNetwork() {\n        for (const l of this.layers) l.recallNeurons();\n    }\n\n    meshAllNeurons() {\n        let connections = 0;\n        for (let index = 1; index < this.layers.length; index++) {\n            const firstLayer = this.layers[index - 1];\n            const secondLayer = this.layers[index];\n            for (const target of secondLayer.getNeurons()) {\n                for (const source of firstLayer.getNeurons()) {\n                    // create link with deterministic weight seed\n                    (target as any).createLink(source, -1 + 0.1 * connections++);\n                }\n            }\n        }\n    }\n\n    trainBackpropagation(pattern: Pattern, itterations: number, steps: number) {\n        const maxLayerIndex = this.layers.length - 1;\n        for (let step = 0; step < steps; step++) {\n            for (let i = 0; i < itterations; i++) {\n                pattern.activatePatternRandom();\n                this.recallNetwork();\n                for (const neuron of this.layers[maxLayerIndex].getNeurons()) {\n                    (neuron as any).calculateEvaluateOutputError();\n                }\n                for (let k = maxLayerIndex; k > 0; k--) {\n                    for (const neuron of this.layers[k].getNeurons()) {\n                        (neuron as any).calculateEvaluateOutputErrorHiddenNeurons(Network.FLAT_SPOT);\n                    }\n                }\n                for (let k = maxLayerIndex; k > 0; k--) {\n                    for (const neuron of this.layers[k].getNeurons()) {\n                        for (const link of (neuron as any).getLinks()) {\n                            const weightDecayTerm = Math.pow(10, -Network.WEIGHT_DECAY) * link.weight;\n                            const momentumTerm = Network.ALPHA * link.deltaWeigthOld;\n                            link.deltaWeigth = link.deltaWeigth - Network.GAMMA * link.source.output * (neuron as any).getOutputDerived() * (neuron as any).getOutputError() + momentumTerm - weightDecayTerm;\n                        }\n                    }\n                }\n                for (let k = maxLayerIndex; k > 0; k--) {\n                    for (const neuron of this.layers[k].getNeurons()) {\n                        for (const link of (neuron as any).getLinks()) {\n                            link.weight = link.weight + link.deltaWeigth;\n                            link.deltaWeigthOld = link.deltaWeigth;\n                            link.deltaWeigth = 0.0;\n                        }\n                    }\n                }\n                for (let k = maxLayerIndex; k > 0; k--) {\n                    for (const neuron of this.layers[k].getNeurons()) {\n                        (neuron as any).setOutputError(0.0);\n                    }\n                }\n            }\n        }\n    }\n\n    resetLinks() {\n        for (const layer of this.layers) layer.resetLinks();\n    }\n\n    rms(patterns: Pattern) {\n        let result = 0.0;\n        const patternNumber = patterns.getNumberOfPattern();\n        for (let i = 0; i < patternNumber; i++) {\n            patterns.activatePattern(i);\n            this.recallNetwork();\n            for (const neuron of this.layers[this.layers.length - 1].getNeurons()) {\n                (neuron as any).calculateEvaluateOutputError();\n                result += Math.pow((neuron as any).getOutputError(), 2.0);\n            }\n        }\n        return result / patternNumber;\n    }\n\n    toString() {\n        return `{\"layers\":[${this.layers.map(l => l.toString()).join(',')}]}`;\n    }\n}\n", "import {Neuron} from './Neuron';\n\nexport class Layer {\n    neurons: Neuron[] = [];\n\n    addNeuron(n: Neuron) {\n        this.neurons.push(n);\n    }\n\n    getNeurons() {\n        return Object.freeze([...this.neurons]);\n    }\n\n    recallNeurons() {\n        for (const n of this.neurons) n.recall();\n    }\n\n    resetLinks() {\n        for (const neuron of this.neurons) {\n            for (const link of neuron.getLinks() as any) {\n                link.weight = 0.1 * (Math.random() - 0.5);\n            }\n        }\n    }\n\n    toString() {\n        return `{\"nodes\":[${this.neurons.map(n => n.toString()).join(',')}]}`;\n    }\n}\n", "import type {Neuron} from './Neuron';\n\nexport class Link {\n    source: Neuron | null = null;\n    weight: number = 0;\n    deltaWeigth: number = 0;\n    deltaWeigthOld: number = 0;\n}\n", "import {Link} from './Link';\n\nexport enum NeuronType { INPUT = 'INPUT', OUTPUT = 'OUTPUT', INNER = 'INNER' }\n\nexport class Neuron {\n    links: Link[] = [];\n    output = 0.0;\n    outputExpected = 0.0;\n    outputError = 0.0;\n    input = 0.0;\n    outputDerived = 1.0;\n    type: NeuronType;\n\n    constructor(type: NeuronType = NeuronType.INNER) {\n        this.type = type;\n    }\n\n    createLink(source: Neuron, weight: number) {\n        if (!source) throw new Error('source is null');\n        if (source === this) throw new Error('source equals this');\n        const link = new Link();\n        link.source = source;\n        link.weight = weight;\n        this.links.push(link);\n    }\n\n    getInput() {\n        return this.input;\n    }\n\n    getLinks(): Link[] {\n        return this.links;\n    }\n\n    getOutput() {\n        return this.output;\n    }\n\n    getOutputDerived() {\n        return this.outputDerived;\n    }\n\n    getOutputExpected() {\n        return this.outputExpected;\n    }\n\n    isInputNeuron() {\n        return this.type === NeuronType.INPUT;\n    }\n\n    isInnerNeuron() {\n        return this.type === NeuronType.INNER;\n    }\n\n    isOutputNeuron() {\n        return this.type === NeuronType.OUTPUT;\n    }\n\n    setInput(v: number) {\n        if (this.type !== NeuronType.INPUT) throw new Error('IllegalState: not input neuron');\n        this.input = v;\n    }\n\n    recall() {\n        if (this.type === NeuronType.INPUT) {\n            this.output = this.input;\n            this.outputDerived = 1.0;\n        } else {\n            let sum = 0.0;\n            for (const link of this.links) {\n                // use getter to avoid direct property access on linked neuron\n                sum += (link.source!.getOutput()) * link.weight;\n            }\n            this.output = this.functionFermi(sum);\n            this.outputDerived = this.functionFermiDerive(sum);\n        }\n    }\n\n    calculateEvaluateOutputError() {\n        if (this.type !== NeuronType.OUTPUT) throw new Error('IllegalArgument: not output');\n        this.outputError = this.output - this.outputExpected;\n    }\n\n    calculateEvaluateOutputErrorHiddenNeurons(m_FlatSpot: number) {\n        if (this.type === NeuronType.INPUT) throw new Error('IllegalArgument: is input');\n        for (const link of this.links) {\n            const derivation = this.outputDerived + m_FlatSpot;\n            const oldError = link.source!.getOutputError();\n            link.source!.setOutputError(derivation * this.outputError * link.weight + oldError);\n        }\n    }\n\n    setOutputError(v: number) {\n        this.outputError = v;\n    }\n\n    getOutputError() {\n        return this.outputError;\n    }\n\n    setOutputExpected(v: number) {\n        this.outputExpected = v;\n    }\n\n    toString() {\n        return `{\"y\":${this.output},\"y_ex\":${this.outputExpected}}`;\n    }\n\n    private functionFermi(x: number) {\n        if (x > 15) return 1.0;\n        if (x < -15) return 0.0;\n        const y = 1.0 / (1.0 + Math.exp(-x));\n        return y;\n    }\n\n    private functionFermiDerive(x: number) {\n        const z = this.functionFermi(x);\n        return z * (1 - z);\n    }\n}\n", "import {Neuron} from './Neuron';\n\nexport class Pattern {\n    protected numberOfPattern = 0;\n\n    // Layer.getNeurons() returns a readonly array; keep readonly in Pattern\n    protected inputNeurons: readonly Neuron[] = [];\n\n    protected outputNeurons: readonly Neuron[] = [];\n\n    protected value: Map<number, Map<Neuron, number>> = new Map();\n\n    bind(network: {\n        getLayers: () => { getNeurons: () => Neuron[] }[]\n    }, table: number[][]) {\n        if (!network) throw new Error('network null');\n        if (!table) throw new Error('table null');\n        if (table.length === 0) throw new Error('empty table');\n\n        const layers = (network as any).getLayers();\n        this.inputNeurons = layers[0].getNeurons();\n        this.outputNeurons = layers[layers.length - 1].getNeurons();\n\n        const inputNeuronNumber = this.inputNeurons.length;\n        const outputNeuronNumber = this.outputNeurons.length;\n        if (inputNeuronNumber + outputNeuronNumber !== table[0].length) throw new Error('dimension mismatch');\n\n        this.numberOfPattern = table.length;\n        this.value = new Map();\n\n        for (let row = 0; row < this.numberOfPattern; row++) {\n            const map = new Map<Neuron, number>();\n            // inputs\n            for (let col = 0; col < inputNeuronNumber; col++) {\n                map.set(this.inputNeurons[col], table[row][col]);\n            }\n            for (let col = 0; col < outputNeuronNumber; col++) {\n                map.set(this.outputNeurons[col], table[row][col + inputNeuronNumber]);\n            }\n            this.value.set(row, map);\n        }\n    }\n\n    getPatterns() {\n        return this.value;\n    }\n\n    activatePatternRandom() {\n        const index = Math.floor(Math.random() * this.numberOfPattern);\n        this.activatePattern(index);\n    }\n\n    activatePattern(index: number) {\n        if (index < 0 || index >= this.numberOfPattern) throw new Error('index out of range');\n        const map = this.value.get(index)!;\n        for (const [neuron, val] of map.entries()) {\n            if (this.inputNeurons.includes(neuron)) neuron.setInput(val);\n            else neuron.setOutputExpected(val);\n        }\n    }\n\n    getNumberOfPattern() {\n        return this.numberOfPattern;\n    }\n}\n", "import {Network} from './Network';\nimport {Layer} from './Layer';\nimport {Neuron, NeuronType} from './Neuron';\nimport {Pattern} from './Pattern';\n\nexport class ModelFactory extends Pattern {\n    private static readonly ALPHA_INCRMENT = Math.PI / 180.0 * 8.0;\n    private static readonly PHASE_INCRMENT = Math.PI / 180.0 * 5.0;\n\n    // Inherits numberOfPattern, inputNeurons, outputNeurons and value from Pattern\n\n    createBindTestPattern(): Network {\n        const network = new Network();\n        const inputChanels = 20;\n        const hiddenNeurons = 15;\n        const outputChanels = 10;\n\n        const layer10 = new Layer();\n        for (let i = 0; i < inputChanels; i++) layer10.addNeuron(new Neuron(NeuronType.INPUT));\n        network.addLayer(layer10);\n\n        const layer20b = new Layer();\n        for (let i = 0; i < hiddenNeurons; i++) layer20b.addNeuron(new Neuron());\n        network.addLayer(layer20b);\n\n        const layer30 = new Layer();\n        for (let i = 0; i < outputChanels; i++) layer30.addNeuron(new Neuron(NeuronType.OUTPUT));\n        network.addLayer(layer30);\n\n        network.meshAllNeurons();\n\n        this.inputNeurons = network.getLayers()[0].getNeurons();\n        this.outputNeurons = network.getLayers()[network.getLayers().length - 1].getNeurons();\n        this.value = new Map();\n\n        const maxFrequenceFactor = outputChanels;\n        this.numberOfPattern = 0;\n        let phase = 0;\n        for (let frequenceFactor = 1; frequenceFactor <= maxFrequenceFactor; frequenceFactor++) {\n            for (let indexPhase = 0; indexPhase < inputChanels; indexPhase++) {\n                phase += ModelFactory.PHASE_INCRMENT * frequenceFactor;\n                for (let index = 0; index < inputChanels; index++) {\n                    const alpha = ModelFactory.ALPHA_INCRMENT * index;\n                    const input = 0.6 + 0.5 * Math.cos(frequenceFactor * alpha + phase);\n                    let map = this.value.get(this.numberOfPattern);\n                    if (!map) {\n                        map = new Map();\n                        this.value.set(this.numberOfPattern, map);\n                    }\n                    map.set(this.inputNeurons[index], input);\n                }\n                for (let output = 1; output <= outputChanels; output++) {\n                    let map = this.value.get(this.numberOfPattern)!;\n                    if (output === frequenceFactor) map.set(this.outputNeurons[output - 1], 0.9);\n                    else map.set(this.outputNeurons[output - 1], 0.1);\n                }\n                this.numberOfPattern++;\n            }\n        }\n\n        network.resetLinks();\n        return network;\n    }\n\n    getNumberOfPattern() {\n        return this.numberOfPattern;\n    }\n}\n", "import {ModelFactory} from './ModelFactory';\nimport {Network} from './Network';\n\n// Minimal browser glue to demonstrate TS ANN running in the existing HTML page\nfunction $(id: string): HTMLElement | null {\n  return document.getElementById(id);\n}\n\nfunction writeInfo(msg: string) {\n  const el = $('infoLabelContainer1');\n  if (el) el.textContent = msg;\n  console.log(msg);\n}\n\nexport function initApp() {\n  // guard: ensure init runs only once (idempotent)\n  if ((window as any).__tsInitDone) {\n    console.log('initApp: already initialized \u2014 skipping');\n    return;\n  }\n  (window as any).__tsInitDone = true;\n\n  writeInfo('Initializing ANN (TypeScript)...');\n  const factory = new ModelFactory();\n  const network: Network = factory.createBindTestPattern();\n\n  writeInfo('Created network with layers: ' + network.getLayers().length);\n  // Reset network on load so visualization starts from a clean state\n  try {\n    network.resetLinks();\n    network.recallNetwork();\n    writeInfo('Network reset on load (TS).');\n  } catch (e) {\n    console.warn('Failed to reset network on load', e);\n  }\n\n  // If the legacy WebGL renderer is present, provide it with the network JSON\n  function publishModel() {\n    if (typeof (window as any).renderData === 'function') {\n      try {\n        (window as any).renderData(network.toString());// If renderer exposes a forceRender hook, call it to ensure immediate repaint\n        if (typeof (window as any).forceRender === 'function') {\n          try { (window as any).forceRender(); } catch (e) { console.warn('forceRender failed', e); }\n        }\n        writeInfo('Sent model to WebGL renderer');\n      } catch (e) {\n        console.warn('Failed to call renderData', e);\n      }\n    }\n  }\n  publishModel();\n\n  // Hook up simple UI buttons if present (use static controls in index.html)\n  const trainBtn = document.getElementById('ts-train-button') as HTMLButtonElement | null;\n  const resetBtn = document.getElementById('ts-reset-button') as HTMLButtonElement | null;\n  const recallBtn = document.getElementById('ts-recall-button') as HTMLButtonElement | null;\n  const stopBtn = document.getElementById('ts-stop-button') as HTMLButtonElement | null;\n  const intervalInput = document.getElementById('ts-recall-interval') as HTMLInputElement | null;\n\n  // state for recall loop\n  let recallTimer: number | null = null;\n  let recallIndex = 0;\n\n  function setRecallRunning(running: boolean) {\n    if (recallBtn) recallBtn.disabled = running;\n    if (stopBtn) stopBtn.disabled = !running;\n    if (intervalInput) intervalInput.disabled = running;\n  }\n\n  if (trainBtn) {\n    trainBtn.addEventListener('click', () => {\n      console.log('Train button clicked');\n      // stop recall if running to avoid interference\n      if (recallTimer !== null) {\n        clearInterval(recallTimer);\n        recallTimer = null;\n        setRecallRunning(false);\n        writeInfo('Recall stopped due to training');\n      }\n      // Use fixed default iterations to simplify the UI\n      const DEFAULT_ITERATIONS = 10;\n      // Use steps=2 and small chunk to keep UI responsive\n      trainAsync(DEFAULT_ITERATIONS, 100, 100).catch((e) => {\n        console.error('Async training failed', e);\n        if (trainBtn) trainBtn.disabled = false;\n      });\n    });\n  }\n\n  if (resetBtn) {\n    resetBtn.addEventListener('click', () => {\n      console.log('Reset button clicked');\n      // stop recall if running\n      if (recallTimer !== null) {\n        clearInterval(recallTimer);\n        recallTimer = null;\n        setRecallRunning(false);\n        writeInfo('Recall stopped due to reset');\n      }\n      // perform reset and update visualization\n      network.resetLinks();\n      try {\n        network.recallNetwork();\n      } catch (e) {\n        console.warn('Failed to recall network after reset', e);\n      }\n      writeInfo('Network links reset (TS).');\n      publishModel();\n    });\n  }\n\n  if (recallBtn) {\n    recallBtn.addEventListener('click', () => {\n      console.log('Recall button clicked');\n      if (recallTimer !== null) {\n        console.log('Recall already running');\n        return;\n      }\n      // read interval from input (milliseconds) and validate\n      let intervalMs = 50;\n      if (intervalInput) {\n        const raw = String(intervalInput.value || '').trim();\n        const parsed = raw.length > 0 ? Number(raw) : NaN;\n        if (Number.isFinite(parsed) && parsed >= 10) intervalMs = Math.floor(parsed);\n      }\n      const intervalClamped = Math.max(10, Math.floor(intervalMs));\n\n      // start cycling through patterns every intervalClamped ms\n      recallIndex = 0;\n      recallTimer = window.setInterval(() => {\n        try {\n          const patterns = (factory as any).getNumberOfPattern ? (factory as any).getNumberOfPattern() : 0;\n          if (patterns <= 0) return;\n          // activate in sequence\n          (factory as any).activatePattern(recallIndex % patterns);\n          network.recallNetwork();\n          publishModel();\n          recallIndex++;\n        } catch (e) {\n          console.warn('Recall interval failed', e);\n        }\n      }, intervalClamped) as unknown as number;\n\n      setRecallRunning(true);\n      // show active interval in a separate info label for clarity\n      const intervalLabel = document.getElementById('infoLabelContainer2');\n      if (intervalLabel) intervalLabel.textContent = 'Recall interval: ' + intervalClamped + ' ms';\n      writeInfo('Recall started (interval ' + intervalClamped + 'ms)');\n    });\n  }\n\n  if (stopBtn) {\n    stopBtn.addEventListener('click', () => {\n      console.log('Stop button clicked');\n      if (recallTimer !== null) {\n        clearInterval(recallTimer);\n        recallTimer = null;\n        setRecallRunning(false);\n        const intervalLabel = document.getElementById('infoLabelContainer2');\n        if (intervalLabel) intervalLabel.textContent = '';\n        writeInfo('Recall stopped');\n      }\n    });\n  }\n\n  // Async chunked trainer to avoid blocking the UI (standalone so UI wiring can call it)\n  async function trainAsync(totalIterations: number, steps: number, chunk = 2) {\n    if (trainBtn) trainBtn.disabled = true;\n    writeInfo('Training (async)...');\n    console.log('trainAsync start', { totalIterations, steps, chunk });\n\n    // total represents the remaining \"calls\" we will make; keep history for logging\n    let total = totalIterations * steps;\n    let completed = 0;\n    const LOG_EVERY_MS = 200; // at most log this often (safety)\n    let lastLog = Date.now();\n\n    while (total > 0) {\n      const run = Math.min(chunk, total);\n      for (let r = 0; r < run; r++) {\n        // each call applies one small training step\n        network.trainBackpropagation(factory as any, 10, 10);\n        total--;\n        completed++;\n      }\n\n      // After each chunk, push update to the renderer\n      publishModel();\n\n      // Log progress and RMS periodically\n      try {\n        const now = Date.now();\n        if (now - lastLog >= LOG_EVERY_MS) {\n          lastLog = now;\n          let rmsVal: number | string = 'n/a';\n          try { rmsVal = network.rms(factory as any).toFixed(6); } catch (e) { /* ignore */ }\n          console.log('Training progress - remaining:', total, 'completed:', completed, 'RMS:', rmsVal);\n          writeInfo('Training... remaining iterations: ' + total + (typeof rmsVal === 'string' ? '' : ' RMS=' + rmsVal));\n        } else {\n          // still update info label with remaining count at least\n          writeInfo('Training... remaining iterations: ' + total);\n        }\n      } catch (e) {\n        console.warn('Progress logging failed', e);\n      }\n\n      // Yield to the event loop to keep UI responsive\n      await new Promise((resolve) => setTimeout(resolve, 20));\n    }\n\n    // Final RMS and cleanup\n    try {\n      const rms = network.rms(factory as any);\n      writeInfo('Training done. RMS=' + rms.toFixed(6));\n      console.log('trainAsync done. final RMS=', rms);\n    } catch (e) {\n      console.warn('Failed to compute final RMS after training', e);\n    }\n\n    if (trainBtn) trainBtn.disabled = false;\n  }\n\n  writeInfo('ANN (TypeScript) ready.');\n\n  // Auto-start training shortly after load: stop any recall and begin training.\n  (function autoStartTraining() {\n    const AUTO_ITERATIONS = 10;\n    // Delay a bit to allow the UI and renderer to settle\n    setTimeout(() => {\n      try {\n        console.log('Auto-starting training on load');\n        // stop recall if running\n        if (recallTimer !== null) {\n          clearInterval(recallTimer);\n          recallTimer = null;\n          setRecallRunning(false);\n          writeInfo('Recall stopped due to auto-training');\n        }\n        // start async training with the same defaults as the Train button\n        trainAsync(AUTO_ITERATIONS, 100, 100).catch((e) => {\n          console.error('Auto training failed', e);\n        });\n      } catch (e) {\n        console.warn('Auto-start training failed', e);\n      }\n    }, 200);\n  })();\n}\n\n// Expose initApp globally so an external bootstrap (or manual call) can trigger it reliably\n;(window as any)[\"initApp\"] = initApp;\nconsole.log('initApp exported on window');\n\n// If the document is already loaded by the time this module runs, call initApp() immediately\nif (typeof document !== 'undefined' && document.readyState === 'complete') {\n  try {\n    initApp();\n  } catch (e) {\n    console.error('Error auto-initializing TS app after readyState complete', e);\n  }\n}\n\n// Auto-init when loaded in browser\nif (typeof window !== 'undefined') {\n  window.addEventListener('load', () => {\n    try {\n      initApp();\n    } catch (e) {\n      console.error('Error initializing TS app', e);\n    }\n  });\n}\n"],
  "mappings": "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",
  "names": ["Network", "_Network", "layer", "l", "connections", "index", "firstLayer", "secondLayer", "target", "source", "pattern", "itterations", "steps", "maxLayerIndex", "step", "i", "neuron", "k", "link", "weightDecayTerm", "momentumTerm", "patterns", "result", "patternNumber", "Layer", "n", "neuron", "link", "Link", "Neuron", "type", "source", "weight", "link", "Link", "v", "sum", "m_FlatSpot", "derivation", "oldError", "x", "z", "Pattern", "network", "table", "layers", "inputNeuronNumber", "outputNeuronNumber", "row", "map", "col", "index", "neuron", "val", "ModelFactory", "_ModelFactory", "Pattern", "network", "Network", "inputChanels", "hiddenNeurons", "outputChanels", "layer10", "Layer", "i", "Neuron", "layer20b", "layer30", "maxFrequenceFactor", "phase", "frequenceFactor", "indexPhase", "index", "alpha", "input", "map", "output", "$", "id", "writeInfo", "msg", "el", "initApp", "factory", "ModelFactory", "network", "e", "publishModel", "trainBtn", "resetBtn", "recallBtn", "stopBtn", "intervalInput", "recallTimer", "recallIndex", "setRecallRunning", "running", "trainAsync", "intervalMs", "raw", "parsed", "intervalClamped", "patterns", "intervalLabel", "totalIterations", "steps", "chunk", "total", "completed", "LOG_EVERY_MS", "lastLog", "run", "r", "now", "rmsVal", "resolve", "rms"]
}
